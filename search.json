[
  {
    "objectID": "libraries.html",
    "href": "libraries.html",
    "title": "Python for High Resolution Mass Spectrometry",
    "section": "",
    "text": "Learn to code, code to learn.\nAn initial search for python packages to analyze high resolution mass spectrometry data, I found a few that seem rather useful. I will quickly explore them below.",
    "crumbs": [
      "Python for High Resolution Mass Spectrometry"
    ]
  },
  {
    "objectID": "libraries.html#molmass",
    "href": "libraries.html#molmass",
    "title": "Python for High Resolution Mass Spectrometry",
    "section": "molmass",
    "text": "molmass\nThe molmass package can be installed from the Python package index: https://pypi.org/project/molmass/.\n\n\n\n\n\n\nWarning\n\n\n\nThe latest version of molmass requires Python version 3.8.\n\n\n\nimport molmass \nimport numpy as np \nimport pandas as pd \nimport sys\n\nYou can check your version of a package with the .__version__ attribute. The latest version is ‘2022.12.9’.\n\nprint(sys.version)\n\n3.10.18 (main, Jun  4 2025, 04:04:42) [GCC 13.3.0]\n\n\n\nprint(molmass.__version__)\n\n2025.4.14\n\n\nLet’s explore the properties of caffeine as detailed in the code example.\n\nfrom molmass import Formula\nf = Formula('C8H10N4O2')  # Caffeine\nf\n\nFormula('C8H10N4O2')\n\n\nAnd look up the average, nominal and monoisotopic mass.\n\nf.mass  # average mass\n\n194.19095199999998\n\n\n\nf.nominal_mass  # == f.isotope.massnumber in previous package version\n\n194\n\n\n\nf.monoisotopic_mass  # == f.isotope.mass in previous package version\n\n194.08037557916\n\n\n\nf.composition().dataframe()\n\n\n\n\n\n\n\n\nCount\nRelative mass\nFraction\n\n\nElement\n\n\n\n\n\n\n\nC\n8\n96.085920\n0.494801\n\n\nH\n10\n10.079410\n0.051905\n\n\nN\n4\n56.026812\n0.288514\n\n\nO\n2\n31.998810\n0.164780\n\n\n\n\n\n\n\nNext, let’s compute the mass spectrum for caffeine for all the different isotope combinations.\n\ndf = f.spectrum().dataframe()\ndf\n\n\n\n\n\n\n\n\nRelative mass\nFraction\nIntensity %\nm/z\n\n\nMass number\n\n\n\n\n\n\n\n\n194\n194.080376\n8.988278e-01\n1.000000e+02\n194.080376\n\n\n195\n195.082873\n9.262511e-02\n1.030510e+01\n195.082873\n\n\n196\n196.084968\n8.021964e-03\n8.924917e-01\n196.084968\n\n\n197\n197.087214\n5.004776e-04\n5.568114e-02\n197.087214\n\n\n198\n198.089410\n2.370420e-05\n2.637235e-03\n198.089410\n\n\n199\n199.091577\n9.094718e-07\n1.011842e-04\n199.091577\n\n\n200\n200.093769\n2.738857e-08\n3.047143e-06\n200.093769\n\n\n201\n201.095939\n6.190814e-10\n6.887653e-08\n201.095939\n\n\n202\n202.098016\n1.031659e-11\n1.147783e-09\n202.098016\n\n\n203\n203.099952\n1.265261e-13\n1.407679e-11\n203.099952\n\n\n204\n204.101915\n1.092906e-15\n1.215924e-13\n204.101915\n\n\n205\n205.104365\n4.529557e-18\n5.039404e-16\n205.104365\n\n\n\n\n\n\n\nLet’s plot the the mass spectrum…\n\nimport matplotlib.pyplot as plt\n\n\n\nCode\nfig, ax = plt.subplots()\nax.scatter(df['Relative mass'], df['Fraction'])\nax.set_xlabel('Monoisotopic mass (u)')\nax.set_ylabel('Mass fraction')\nax.set_title('Caffeine mass spectrum');\n\n\n\n\n\n\n\n\n\nHere is also the mass spectrum for the different isotopes of iron.\n\nFe = Formula('Fe')\n\n\nFe.spectrum().dataframe()\n\n\n\n\n\n\n\n\nRelative mass\nFraction\nIntensity %\nm/z\n\n\nMass number\n\n\n\n\n\n\n\n\n54\n53.939609\n0.05845\n6.370294\n53.939609\n\n\n56\n55.934936\n0.91754\n100.000000\n55.934936\n\n\n57\n56.935393\n0.02119\n2.309436\n56.935393\n\n\n58\n57.933274\n0.00282\n0.307344\n57.933274\n\n\n\n\n\n\n\n\nCH2 = Formula('CH2')\nCH2.monoisotopic_mass\n\n14.01565006446",
    "crumbs": [
      "Python for High Resolution Mass Spectrometry"
    ]
  },
  {
    "objectID": "libraries.html#pyhrms",
    "href": "libraries.html#pyhrms",
    "title": "Python for High Resolution Mass Spectrometry",
    "section": "pyhrms",
    "text": "pyhrms\nNeed to look into this.\nSee: https://pypi.org/project/pyhrms/",
    "crumbs": [
      "Python for High Resolution Mass Spectrometry"
    ]
  },
  {
    "objectID": "libraries.html#pymzml",
    "href": "libraries.html#pymzml",
    "title": "Python for High Resolution Mass Spectrometry",
    "section": "pymzml",
    "text": "pymzml\nNeed to look into this.\nSee: https://pypi.org/project/pymzml/\nThis seems to be an important package. Here is the documentation: https://pymzml.readthedocs.io/en/latest/",
    "crumbs": [
      "Python for High Resolution Mass Spectrometry"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to kendrick",
    "section": "",
    "text": "Our lab, the Rijkserfgoedlaboratorium in Amsterdam, currently experiments with direct ionization coupled with high resolution mass spectrometry using Thermo ASAP probe and Orbitrap HRMS. This chemical analysis technique seems well suited to analyze complex polymeric samples. Visualization of the resulting data in so-called Kendrick mass plots provides a means to efficiently explore this type of data.\nCreating these plots with Excel is tedious and prone to error. Objective of the kendrick Python package is to enable the automatic creation of Kendrick mass plots from raw data. This open source package is developed out in the open and will be made available for installation as soon as possible.\nIf you are curious and can’t wait for a pip installable package, take a look at our documentation and notebooks.\nLast updated: 2025-06-20",
    "crumbs": [
      "Welcome to kendrick"
    ]
  },
  {
    "objectID": "high-resolution-mass-spectrometry.html",
    "href": "high-resolution-mass-spectrometry.html",
    "title": "High resolution mass spectrometry",
    "section": "",
    "text": "Given our ability to create high precision m/z values by time averaged centroiding, we should now be able to derive statistics and deduce the elemental composition of different ions in our data.\n\nfrom kendrick import read_mzml, histogram, get_time_averaged_centroids\n\n\nmzml_file = '/home/frank/Work/DATA/kendrick-data/Ref0443_casein_asap01.mzML' # TODO: create download function \ndf_pos, df_min = read_mzml(mzml_file)\n\nmz_hist = histogram(df_pos)\nmz_centroids = get_time_averaged_centroids(mz_hist)\n\n\nmz_x, mz_y = mz_centroids.T\n\nLet’s start by plotting this.\n\nimport matplotlib.pyplot as plt \nimport numpy as np\n\n\nfig, ax = plt.subplots()\nax.vlines(mz_x, ymin=np.zeros_like(mz_x), ymax=mz_y)\n\n\n\n\n\nidxs = np.argsort(mz_y)[::-1]\n\n\nmz_sorted = mz_centroids[idxs]\n\n\nmz_sorted\n\narray([[2.57247150e+02, 4.94319338e+09],\n       [2.29216050e+02, 1.46894206e+09],\n       [2.55233050e+02, 1.17589672e+09],\n       ...,\n       [1.60306550e+02, 4.08524079e+03],\n       [1.48418350e+02, 4.08524079e+03],\n       [1.31345550e+02, 4.08524079e+03]])\n\n\nFor now let’s pick the 10th mz value…\n\nmz10 = mz_sorted[10][0]\n\n\nmz10\n\n197.12845\n\n\nCan we use molmass or pyopenms to deduce the elemental composition?\n\nimport molmass as mm\n\nThis is the latest version\n\nmm.__version__\n\n'2023.8.30'\n\n\n\nf = mm.Formula('CH2')\n\n\nf.spectrum().dataframe()\n\n\n\n\n\n\n\n\nRelative mass\nFraction\nIntensity %\nm/z\n\n\nMass number\n\n\n\n\n\n\n\n\n14\n14.015650\n9.890725e-01\n1.000000e+02\n14.015650\n\n\n15\n15.019066\n1.092505e-02\n1.104575e+00\n15.019066\n\n\n16\n16.025297\n2.473800e-06\n2.501132e-04\n16.025297\n\n\n17\n17.031558\n1.415075e-10\n1.430709e-08\n17.031558\n\n\n\n\n\n\n\nLet’s generate a bunch of elemental compositions…\n\nimport numpy as np\n\n\npositions = np.indices([2, 2, 2]).T.reshape(-1, 3)\npositions\n\narray([[0, 0, 0],\n       [1, 0, 0],\n       [0, 1, 0],\n       [1, 1, 0],\n       [0, 0, 1],\n       [1, 0, 1],\n       [0, 1, 1],\n       [1, 1, 1]])\n\n\n\ndef formula(pos):  \n    n1, n2, n3 = pos \n    formula_str = 'C'\n\n\nformula_list = [] \nelements = ['C', 'H', 'O']\nfor p in positions: \n    formula = ''\n    for i, n in enumerate(p): \n        if n == 0: \n            elem_str = ''\n        elif n == 1: \n            elem_str = elements[i]\n        else: \n            elem_str = f'{elements[i]}{n}'\n        formula = formula + elem_str\n    \n    formula_list.append(formula)\n\n\nformula_list\n\n['', 'C', 'H', 'CH', 'O', 'CO', 'HO', 'CHO']\n\n\n\n'C' * 0 + 'H' * 2\n\n'HH'\n\n\n\nelements np.unique(np.array(list('CHH')), return_counts=True)))\n\n[(array(['C', 'H'], dtype='&lt;U1'),), (array([1, 2]),)]\n\n\n\nunique, counts\n\n(array(['C', 'H'], dtype='&lt;U1'), array([1, 2]))",
    "crumbs": [
      "High resolution mass spectrometry"
    ]
  },
  {
    "objectID": "kendrick-mass-defect.html",
    "href": "kendrick-mass-defect.html",
    "title": "The Kendrick mass defect",
    "section": "",
    "text": "Before we can create Kendrick plots we need to understand exactly how to calculate Kendrick mass and Kendrick mass defects for a given molecule. Let’s start with the Wikipedia pages on mass spectrometry and monoisotopic mass. Being a physicist I must confess I wasn’t aware of the multitude of mass definitions that need to be carefully distinguished. Also, I wasn’t aware that different definitions of mass defect are being used in physics and chemistry.\nReason for this difference between physics and chemistry seems to be that within nuclear physics it is necessary to distinguish between the mass of proton versus neutrons. Within chemistry this distinction would unnecessarily complicate the analysis. Instead, a premise of chemical mass spectrometry is that both protons and neutrons carry a similar mass of 1/12th of the weight of a carbon atom.\nTo my understanding the terms exact mass and monoisotopic mass are equivalent.\nLet’s check how we can calculate the expected up the nominal mass and the exact mass for given monomer with the mendeleev python package.",
    "crumbs": [
      "The Kendrick mass defect"
    ]
  },
  {
    "objectID": "kendrick-mass-defect.html#kendrick-mass-and-kendrick-mass-defect",
    "href": "kendrick-mass-defect.html#kendrick-mass-and-kendrick-mass-defect",
    "title": "The Kendrick mass defect",
    "section": "Kendrick mass and Kendrick mass defect",
    "text": "Kendrick mass and Kendrick mass defect\nAccording to wikipedia the Kendrick mass for a family of compounds \\(F\\) is given by\n\\[ \\mathrm{Kendrick~mass}~(F) = (\\mathrm{observed~mass}) \\times \\frac{\\mathrm{nominal~mass~(F)}}{\\mathrm{exact~mass~(F)}}.\\]\n\nFor hydrocarbon analysis, \\(F = \\mathrm{CH_2}\\).\n\nThis is not very clear.\nAs a numerical example, suppose we measure the hypothetical molecule \\(\\mathrm{C_2H_4}\\). The exact (or mono-isotopic) mass would be 28.03130012892 u.\nThe exact mass for the Kendrick monomer unit \\(\\mathrm{CH_2}\\) is 14.01565006446 u. This means the the exact Kendrick mass is\n\\[ (28.03130012892) \\times \\frac{14}{14.01565006446 } = 28~ \\mathrm{Kendrick~mass~units} \\].\nThe Kendrick mass defect of a specific measured molecular mass is the fractional part of the Kendrick Mass. Alternatively, it is the difference between the precise Kendrick mass and the nominal Kendrick mass.\nThe exact (or monoisotopic) mass of each chemical element deviates from the nominal mass that one would expect based on the number of nucleons (protons plus neutrons) present in the nucleus. This deviation is unique for each type of atom or molecule and is called the mass defect…\nFurther introduction is given by (Fouquet 2019).",
    "crumbs": [
      "The Kendrick mass defect"
    ]
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting started with Python",
    "section": "",
    "text": "In order to make full use of kendrick you need to be able to install Python packages and run Python code in Jupyter notebooks on your computer. The quickest and easiest way to get started with Jupyter notebooks is by downloading and installing the JupyterLab Desktop (JLD) installer for your operating system from the official github repository.\n\n\n\n\n\n\n\nNote\n\n\n\nThe first time you start JupyterLab Desktop you additionally need to install the default Python environment from the start menu. To do so you need to hoover and click on the word ‘install’ on the bottom of the start up screen.\n\n\nAre you running Jupyterlab Desktop on Linux or MacOS? In that case you also need to install mono via your package manager! For installation details see: pyRawTools.\nFinally you can install or update (with the -U option) the kendrick package from the Python Package index pypi.org by executing this command from a code cell in a Jupyter notebook:\n%pip install -U kendrick \nFor more information about JupyterLab Desktop see the JLD user guide.\nThat is it! You now are ready to open up your explore your high resolution mass spectrometry data!",
    "crumbs": [
      "Getting started with Python"
    ]
  },
  {
    "objectID": "exploring.html",
    "href": "exploring.html",
    "title": "Exploring half a million molecules",
    "section": "",
    "text": "For our ASAP project research team we created a Nextcloud folder that we can use to easily share our data with fairdatanow Python package. Let’s take a look what Wim has uploaded so far.\n\nfrom fairdatanow import DataViewer\nimport os\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\nconfiguration = {\n    'url': \"https://laboppad.nl/asap-data\",\n    'user':    os.getenv('NC_AUTH_USER'),\n    'password': os.getenv('NC_AUTH_PASS')\n}\n\n\ndv = DataViewer(configuration)\n\n\ndv\n\n\n\n\n\n  \n\n\n\n\nFor this example we want to download a demo data file Ref0443_casein_asap01.RAW from the Nextcloud server to our local computer. This can be done by typing the filename and Enter key in the search bar. We can now select the file by clicking the row by clicking. Downloading the selection is done with the method .download_selected()\n\nfiles = dv.download_selected()\n\nReady with downloading 1 selected remote files to local cache: /home/frank/.cache/fairdatanow                                                                      \n\n\n\n\n\n\n\n\nNote\n\n\n\nDue to security restrictions at this moment you can not yet download from our Nextcloud server unless you are a member of our team! We are working to open up our data for you soon!\n\n\nIt is also possible to export the complete filter settings with the .export_filters() method.\n\ndv.export_filters()\n\n{'columns': ['path', 'size', 'modified'],\n 'extensions': ['.raw'],\n 'search': 'ref0443',\n 'show_directories': False,\n 'show_filters': True,\n 'use_regex': False}",
    "crumbs": [
      "Exploring half a million molecules"
    ]
  },
  {
    "objectID": "exploring.html#exploring-our-nextcloud-data",
    "href": "exploring.html#exploring-our-nextcloud-data",
    "title": "Exploring half a million molecules",
    "section": "",
    "text": "For our ASAP project research team we created a Nextcloud folder that we can use to easily share our data with fairdatanow Python package. Let’s take a look what Wim has uploaded so far.\n\nfrom fairdatanow import DataViewer\nimport os\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\nconfiguration = {\n    'url': \"https://laboppad.nl/asap-data\",\n    'user':    os.getenv('NC_AUTH_USER'),\n    'password': os.getenv('NC_AUTH_PASS')\n}\n\n\ndv = DataViewer(configuration)\n\n\ndv\n\n\n\n\n\n  \n\n\n\n\nFor this example we want to download a demo data file Ref0443_casein_asap01.RAW from the Nextcloud server to our local computer. This can be done by typing the filename and Enter key in the search bar. We can now select the file by clicking the row by clicking. Downloading the selection is done with the method .download_selected()\n\nfiles = dv.download_selected()\n\nReady with downloading 1 selected remote files to local cache: /home/frank/.cache/fairdatanow                                                                      \n\n\n\n\n\n\n\n\nNote\n\n\n\nDue to security restrictions at this moment you can not yet download from our Nextcloud server unless you are a member of our team! We are working to open up our data for you soon!\n\n\nIt is also possible to export the complete filter settings with the .export_filters() method.\n\ndv.export_filters()\n\n{'columns': ['path', 'size', 'modified'],\n 'extensions': ['.raw'],\n 'search': 'ref0443',\n 'show_directories': False,\n 'show_filters': True,\n 'use_regex': False}",
    "crumbs": [
      "Exploring half a million molecules"
    ]
  },
  {
    "objectID": "exploring.html#reading-our-first-.raw-file",
    "href": "exploring.html#reading-our-first-.raw-file",
    "title": "Exploring half a million molecules",
    "section": "Reading our first .raw file",
    "text": "Reading our first .raw file\nFirst step is to read an .raw file containing (already centroided) ASAP-HRMS data. The data can be loaded into a positive and a negative mode dataframe as with the read_raw() function which returns two dataframes for positive and negative mode. This function is based on the pyRawTools python package.\n\nfrom kendrick import read_raw\n\n\nraw_file = '../downloads/kendrick-data/Ref0443_casein_asap01.RAW'\n\n\ndf_pos, df_neg = read_raw(raw_file)\n\nLet’s focus on the positive mode data for now. Here is what the first and last rows of the dataframe looks like.\n\ndf_pos\n\n\n\n\n\n\n\n\nRT\nmz\ninty\n\n\nScan\n\n\n\n\n\n\n\n1\n0.003945\n125.023285\n10221.680664\n\n\n1\n0.003945\n125.059830\n81648.109375\n\n\n1\n0.003945\n125.132690\n35949.582031\n\n\n1\n0.003945\n126.062935\n6891.418945\n\n\n1\n0.003945\n126.099777\n18121.056641\n\n\n...\n...\n...\n...\n\n\n390\n3.005163\n546.237732\n35105.105469\n\n\n390\n3.005163\n548.254578\n52922.070312\n\n\n390\n3.005163\n596.266724\n100884.796875\n\n\n390\n3.005163\n610.248840\n50182.472656\n\n\n390\n3.005163\n722.359741\n28877.074219\n\n\n\n\n271982 rows × 3 columns\n\n\n\nInspecting the df_pos dataframe we find 271982 rows with three columns: 1) RT retention time, 2) mz mass per electrical charge, and 3) inty number of ions. From the first column one can see that this experiment lasted 3 minutes.\nAs we will see, m/z values for identical molecules are slightly jittered due to limited instrumental precision. In order to determine the abundance of different molecules present in the sample, we now need to create time averaged centroided m/z values. This can be achieved by 1) first binning the data in a histogram, 2) then Gaussian smoothing the histogram and locating the peaks. These steps are implemented in the functions histogram() and get_time_averaged_centroids().\nNext step is to explore the data in an interactive visualization. In order to plot half a million data points in a single plot we need to import a special function interactive_plot(). This function makes heavily use of a powerful python package datashader that is designed for fast plotting huge numbers of data points.\n\n\n\n\n\n\nNote\n\n\n\nNote that in order to activate interactive plotting in a Jupyter notebook you need to execute the following notebook magic command in a code cell: %matplotlib widget\n\n\n\nfrom kendrick import histogram, get_time_averaged_centroids, interactive_plot\n\n\nmz_hist = histogram(df_pos)\nmz_centroids = get_time_averaged_centroids(mz_hist)\n\ninteractive_plot(df_pos, mz_hist, mz_centroids)\n\n\n\n\n\n\n\nZooming-in\n\n\n\nsource\n\ninteractive_plot\n\n interactive_plot (df, mz_hist, mz_centroids)\n\nCreate interactive plot for dataframe df.\n\nsource\n\n\nget_time_averaged_centroids\n\n get_time_averaged_centroids (mz_hist_w_xy)\n\nGet peaks (centroids) from histogram.\n\nsource\n\n\nhistogram\n\n histogram (df)\n\nCreate intensity weighed histogram.\n\nsource\n\n\nread_mzml\n\n read_mzml (mzml_file)\n\n*Read mzml_file.\nReturns positive and negative mode dataframes df_pos and df_min.*\n\nsource\n\n\nread_raw\n\n read_raw (raw_file)\n\nRead raw_file into positive and negative mode data frames.",
    "crumbs": [
      "Exploring half a million molecules"
    ]
  }
]